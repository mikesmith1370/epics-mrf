/*
 * Copyright 2015-2021 aquenos GmbH.
 * Copyright 2015-2021 Karlsruhe Institute of Technology.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * This software has been developed by aquenos GmbH on behalf of the
 * Karlsruhe Institute of Technology's Institute for Beam Physics and
 * Technology.
 *
 * This software contains code originally developed by aquenos GmbH for
 * the s7nodave EPICS device support. aquenos GmbH has relicensed the
 * affected poritions of code from the s7nodave EPICS device support
 * (originally licensed under the terms of the GNU GPL) under the terms
 * of the GNU LGPL version 3 or newer.
 */

#include <cmath>
#include <cstdio>
#include <cstring>
#include <functional>
#include <stdexcept>

#include <epicsExport.h>
#include <epicsVersion.h>
#include <iocsh.h>

#include <MrfConsistentAsynchronousMemoryAccess.h>
#include <MrfDeviceRegistry.h>
#include <MrfTime.h>
#include <MrfUdpIpMemoryAccess.h>
#include <mrfEpicsError.h>

using namespace anka::mrf;
using namespace anka::mrf::epics;

namespace {

/**
 * Preheats the cache for a VME-EVG-230. This helps reduce the initialization
 * time of the IOC because preheating can happen for several devices in
 * parallel, while the record initialization itself is not parallelized and
 * would that have to wait for each I/O request to finish before it could
 * continue. There is no error checking here. If there is an error, the memory
 * location simply won't be cached, and the respective error will be presented
 * to the user when the second I/O attempt that is made after checking the cache
 * fails (unless the underlying problem has been resolved by then).
 */
void preheatCacheVmeEvg230(std::shared_ptr<MrfMemoryCache> cache) {
  // This code has been generated by preheat-cache-codegen.py using the output
  // of mrfDumpCache(...). If outuput records are added to the record file, this
  // code section needs to be updated.
  for (std::uint32_t address = 0x00000400; address < 0x00000408; address += 2) {
      cache->tryCacheUInt16(address);
  }
  for (std::uint32_t address = 0x00000440; address < 0x00000448; address += 2) {
      cache->tryCacheUInt16(address);
  }
  cache->tryCacheUInt32(0x00000004);
  for (std::uint32_t address = 0x0000000c; address < 0x0000001c; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000020; address < 0x0000002c; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x0000004c);
  cache->tryCacheUInt32(0x00000050);
  cache->tryCacheUInt32(0x00000060);
  cache->tryCacheUInt32(0x00000070);
  cache->tryCacheUInt32(0x00000074);
  cache->tryCacheUInt32(0x00000080);
  for (std::uint32_t address = 0x00000100; address < 0x00000120; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000180; address < 0x000001c0; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000500);
  cache->tryCacheUInt32(0x00000504);
  for (std::uint32_t address = 0x00000540; address < 0x00000550; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000600; address < 0x00000640; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000800; address < 0x00001000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00008000; address < 0x00010000; address += 4) {
      cache->tryCacheUInt32(address);
  }
}

/**
 * Preheats the cache for a VME-EVR-230RF. This helps reduce the initialization
 * time of the IOC because preheating can happen for several devices in
 * parallel, while the record initialization itself is not parallelized and
 * would that have to wait for each I/O request to finish before it could
 * continue. There is no error checking here. If there is an error, the memory
 * location simply won't be cached, and the respective error will be presented
 * to the user when the second I/O attempt that is made after checking the cache
 * fails (unless the underlying problem has been resolved by then).
 */
void preheatCacheVmeEvr230Rf(std::shared_ptr<MrfMemoryCache> cache) {
  // This code has been generated by preheat-cache-codegen.py using the output
  // of mrfDumpCache(...). If outuput records are added to the record file, this
  // code section needs to be updated.
  for (std::uint32_t address = 0x00000400; address < 0x0000040e; address += 2) {
      cache->tryCacheUInt16(address);
  }
  for (std::uint32_t address = 0x00000440; address < 0x00000448; address += 2) {
      cache->tryCacheUInt16(address);
  }
  for (std::uint32_t address = 0x00000480; address < 0x000004a0; address += 2) {
      cache->tryCacheUInt16(address);
  }
  cache->tryCacheUInt16(0x00000614);
  cache->tryCacheUInt16(0x00000616);
  cache->tryCacheUInt16(0x00000634);
  cache->tryCacheUInt16(0x00000636);
  cache->tryCacheUInt16(0x00000654);
  cache->tryCacheUInt16(0x00000656);
  cache->tryCacheUInt32(0x00000004);
  cache->tryCacheUInt32(0x0000000c);
  cache->tryCacheUInt32(0x00000010);
  cache->tryCacheUInt32(0x00000020);
  cache->tryCacheUInt32(0x00000024);
  cache->tryCacheUInt32(0x00000040);
  cache->tryCacheUInt32(0x0000004c);
  cache->tryCacheUInt32(0x00000080);
  for (std::uint32_t address = 0x00000100; address < 0x0000010c; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000200; address < 0x00000244; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000248; address < 0x00000254; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000258; address < 0x00000264; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000268; address < 0x00000274; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000278; address < 0x00000284; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000288; address < 0x00000294; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00000298; address < 0x000002a4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002a8; address < 0x000002b4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002b8; address < 0x000002c4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002c8; address < 0x000002d4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002d8; address < 0x000002e4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x000002e8; address < 0x000002f4; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x000002f8);
  cache->tryCacheUInt32(0x000002fc);
  cache->tryCacheUInt32(0x00000500);
  cache->tryCacheUInt32(0x00000504);
  for (std::uint32_t address = 0x00000600; address < 0x00000614; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000618);
  for (std::uint32_t address = 0x00000620; address < 0x00000634; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000638);
  for (std::uint32_t address = 0x00000640; address < 0x00000654; address += 4) {
      cache->tryCacheUInt32(address);
  }
  cache->tryCacheUInt32(0x00000658);
  for (std::uint32_t address = 0x00001800; address < 0x00002000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00004000; address < 0x00006000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00020000; address < 0x00022000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00024000; address < 0x00026000; address += 4) {
      cache->tryCacheUInt32(address);
  }
  for (std::uint32_t address = 0x00028000; address < 0x0002a000; address += 4) {
      cache->tryCacheUInt32(address);
  }
}

/**
 * Creates (and registers) a UDP/IP device. EVG and EVR devices are nearly
 * identical with the exception that they use a different base address.
 */
void createUdpIpDevice(const std::string& deviceId,
    const std::string &hostName, std::uint32_t baseAddress,
    const MrfTime &delayBetweenPackets, const MrfTime &udpTimeout,
    int maximumNumberOfTries,
    std::function<void(std::shared_ptr<MrfMemoryCache>)> preheatFunction) {
  std::shared_ptr<MrfUdpIpMemoryAccess> rawDevice = std::make_shared<
      MrfUdpIpMemoryAccess>(hostName, baseAddress, delayBetweenPackets,
      udpTimeout, maximumNumberOfTries);
  std::shared_ptr<MrfConsistentAsynchronousMemoryAccess> consistentDevice =
      std::make_shared<MrfConsistentAsynchronousMemoryAccess>(rawDevice);
  MrfDeviceRegistry::getInstance().registerDevice(std::string(deviceId),
      consistentDevice);
  // We want to preheat the cache. We do not have to check whether the returned
  // pointer is null, because it won't be null if registerDevice did not throw
  // an exception.
  auto cache = MrfDeviceRegistry::getInstance().getDeviceCache(deviceId);
  std::thread preheatThread([cache, preheatFunction]() {
    preheatFunction(cache);
  });
  // We want to continue the preheating in the background, so we detach the
  // thread.
  preheatThread.detach();
}

/**
 * Creates an EVG device with the specified ID that is accessed using the
 * UDP/IP based protocol. Throws an exception if the device cannot be created
 * (e.g. because the device ID is already in use).
 */
void createUdpIpEvgDevice(const std::string& deviceId,
    const std::string &hostName, const MrfTime &delayBetweenPackets,
    const MrfTime &udpTimeout, int maximumNumberOfTries) {
  createUdpIpDevice(deviceId, hostName,
      MrfUdpIpMemoryAccess::baseAddressVmeEvgRegister, delayBetweenPackets,
      udpTimeout, maximumNumberOfTries, preheatCacheVmeEvg230);
}

/**
 * Creates an EVR device with the specified ID that is accessed using the
 * UDP/IP based protocol. Throws an exception if the device cannot be created
 * (e.g. because the device ID is already in use).
 */
void createUdpIpEvrDevice(const std::string& deviceId,
    const std::string &hostName, const MrfTime &delayBetweenPackets,
    const MrfTime &udpTimeout, int maximumNumberOfTries) {
  createUdpIpDevice(deviceId, hostName,
      MrfUdpIpMemoryAccess::baseAddressVmeEvrRegister, delayBetweenPackets,
      udpTimeout, maximumNumberOfTries, preheatCacheVmeEvr230Rf);
}

} // anonymous namespace

extern "C" {

// Data structures needed for the iocsh mrfUdpIpDevice function.
static const iocshArg iocshMrfUdpIpDeviceArg0 = { "device ID", iocshArgString };
static const iocshArg iocshMrfUdpIpDeviceArg1 = { "host name or address",
    iocshArgString };
static const iocshArg iocshMrfUdpIpDeviceArg2 = {
    "min. delay between consecutive UDP packets (seconds)", iocshArgDouble };
static const iocshArg iocshMrfUdpIpDeviceArg3 = { "UDP timeout (seconds)",
    iocshArgDouble };
static const iocshArg iocshMrfUdpIpDeviceArg4 = { "max. number of tries",
    iocshArgInt };
static const iocshArg * const iocshMrfUdpIpDeviceArgs[] =
    { &iocshMrfUdpIpDeviceArg0, &iocshMrfUdpIpDeviceArg1,
        &iocshMrfUdpIpDeviceArg2, &iocshMrfUdpIpDeviceArg3,
        &iocshMrfUdpIpDeviceArg4 };
static const iocshFuncDef iocshMrfUdpIpEvgDeviceFuncDef = {
  "mrfUdpIpEvgDevice",
  5,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVG-230.\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};
static const iocshFuncDef iocshMrfUdpIpEvrDeviceFuncDef = {
  "mrfUdpIpEvrDevice",
  5,
  iocshMrfUdpIpDeviceArgs,
#ifdef IOCSHFUNCDEF_HAS_USAGE
  "Define a UDP/IP connection to a VME-EVR-230RF.\n",
#endif // IOCSHFUNCDEF_HAS_USAGE
};

/**
 * Common implementation of the iocsh mrfUdpIpEvgDevice and mrfUdpIpEvrDevice
 * functions.
 */
static int iocshMrfUdpIpDeviceFunc(const iocshArgBuf *args, bool evr)
    noexcept {
  char *deviceId = args[0].sval;
  char *hostAddress = args[1].sval;
  double delayBetweenPacketsDouble = args[2].dval;
  double udpTimeoutDouble = args[3].dval;
  int maxNumberOfTries = args[4].ival;
  // Verify and convert the parameters.
  if (!deviceId) {
    errorPrintf("Could not create device: Device ID must be specified.");
    return 1;
  }
  if (!std::strlen(deviceId)) {
    errorPrintf("Could not create device: Device ID must not be empty.");
    return 1;
  }
  // Until here our code does not throw. We put the rest of the function into a
  // try-catch statement, so that we handle all other exceptions.
  try {
    if (!hostAddress) {
      throw std::invalid_argument("Host name or address must be specified.");
    }
    if (!std::strlen(hostAddress)) {
      throw std::invalid_argument("Host name or address must not be empty.");
    }
    if (!std::isfinite(delayBetweenPacketsDouble)) {
      throw std::invalid_argument(
          "Min. delay between consecutive UDP packets must be a finite value.");
    }
    if (delayBetweenPacketsDouble <= 0.0) {
      // We use a default value of 400 us. Experiments have shown that this is
      // a good value.
      delayBetweenPacketsDouble = 0.0004;
    }
    // We have to set an upper limit on the delay because it has to be converted
    // to an integer. We could allow a larger value, but such a value would not
    // make sense anyway.
    if (delayBetweenPacketsDouble > 3600.0) {
      throw std::invalid_argument(
          "Min. delay between consecutive UDP packets must not be greater than 3600 seconds.");
    }
    if (!std::isfinite(udpTimeoutDouble)) {
      throw std::invalid_argument("UDP timeout must be a finite value.");
    }
    if (udpTimeoutDouble <= 0.0) {
      // We use a default value of 5ms. For a direct connection, the typical
      // round-trip time is about 750 us. With a switch involved, it is about
      // 770 us. Therefore, 5 ms should be enough even if there are multiple
      // switches involved.
      udpTimeoutDouble = 0.005;
    }
    // We have to set an upper limit on the timeout because it has to be
    // converted to an integer. We could allow a larger value, but such a value
    // would not make sense anyway.
    if (udpTimeoutDouble > 3600.0) {
      throw std::invalid_argument(
          "UDP timeout must not be greater than 3600 seconds.");
    }
    if (maxNumberOfTries <= 0) {
      // Five retries are a good default value because it should cover most
      // situations where a packet is lost because of network congestion.
      maxNumberOfTries = 5;
    }
    MrfTime delayBetweenPackets(std::floor(delayBetweenPacketsDouble),
        std::remainder(delayBetweenPacketsDouble * 1000000000.0, 1000000000.0));
    MrfTime udpTimeout(std::floor(udpTimeoutDouble),
        std::remainder(udpTimeoutDouble * 1000000000.0, 1000000000.0));
    if (evr) {
      createUdpIpEvrDevice(deviceId, hostAddress, delayBetweenPackets,
          udpTimeout, maxNumberOfTries);
    } else {
      createUdpIpEvgDevice(deviceId, hostAddress, delayBetweenPackets,
          udpTimeout, maxNumberOfTries);
    }
  } catch (std::exception &e) {
    anka::mrf::epics::errorPrintf("Could not create device %s: %s", deviceId,
        e.what());
    return 1;
  } catch (...) {
    anka::mrf::epics::errorPrintf("Could not create device %s: Unknown error.",
        deviceId);
    return 1;
  }
  return 0;
}

/**
 * Implementation of the iocsh mrfUdpIpEvgDevice function.
 */
static void iocshMrfUdpIpEvgDeviceFunc(const iocshArgBuf *args) noexcept {
#if EPICS_VERSION_INT >= VERSION_INT(7,0,3,1)
  iocshSetError(iocshMrfUdpIpDeviceFunc(args, false));
#else // EPICS_VERSION_INT >= VERSION_INT(7,0,3,1)
  iocshMrfUdpIpDeviceFunc(args, false);
#endif // EPICS_VERSION_INT >= VERSION_INT(7,0,3,1)
}

/**
 * Implementation of the iocsh mrfUdpIpEvrDevice function.
 */
static void iocshMrfUdpIpEvrDeviceFunc(const iocshArgBuf *args) noexcept {
#if EPICS_VERSION_INT >= VERSION_INT(7,0,3,1)
  iocshSetError(iocshMrfUdpIpDeviceFunc(args, true));
#else // EPICS_VERSION_INT >= VERSION_INT(7,0,3,1)
  iocshMrfUdpIpDeviceFunc(args, true);
#endif // EPICS_VERSION_INT >= VERSION_INT(7,0,3,1)
}

/*
 * Registrar that registers the iocsh commands.
 */
static void mrfRegistrarUdpIp() {
  iocshRegister(&iocshMrfUdpIpEvgDeviceFuncDef, iocshMrfUdpIpEvgDeviceFunc);
  iocshRegister(&iocshMrfUdpIpEvrDeviceFuncDef, iocshMrfUdpIpEvrDeviceFunc);
}

epicsExportRegistrar(mrfRegistrarUdpIp);

}
